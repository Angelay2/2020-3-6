#include <stdio.h>
#include <Windows.h>

// 程序的翻译
// 1. 翻译环境: 最后你编好的C语言程序是在什么环境下变成二进制的 
// 2. 执行环境: 最后你执行的程序是哪里跑 在Windows编好的程序 在Windows跑 Windows就是执行环境
// 组成一个程序的每个源文件通过编译过程分别转换成目标代码
// 每个目标文件由链接捆绑在一起, 形成一个单一而完整的可执行程序
// 链接器同时也会引入标准C函数库中任何被该程序所用到的函数, 而且他可以搜索程序员个人的程序库,
// 将其需要的函数也链接到程序中,
// 1. 预处理 选项gcc -E test.c .o test.i 预处理完成之后就停下来, 预处理之后产生的结果都放在test.i文件中, 形成.i文件, 
// 2. 编译 选项 gcc -S test.c 编译完成之后就停下来, 结果保存在test.s中
// 3. 汇编 gcc -c test.c 汇编完成之后就停下来, 结果保存在test.o中
// 程序的运行
// 1. 程序必须载入内存中, 在有操作系统的环境下, 一般这个由操作系统完成, 在独立的环境中吗程序的载入必须
// 由手工安排, 也可能是通过可执行代码置入只读内存来完成
// 2. 程序的执行便开始, 接着便调用main函数
// 3. 开始执行程序代码, 这个时候程序将使用一个运行时堆栈(使用的临时变量存储于), 
// 存储函数的局部变量和返回地址, 程序同时也可以使用静态内存, 
// 存储于静态内存中的变量在程序的整个执行过程中一直保留着他们的值
// 4. 终止程序, 正常终止main函数, 也有可能是意外终止

// 宏和函数的对比
// 宏不是函数 简单使用用宏, 宏替换在预处理期间就处理好了 函数时要被调用的 现要跳转到函数中 
// 宏适用于比较简单的代码中, 宏没有类型检查 不安全, 从效率角度讲 宏可能大于函数 但不安全
// 宏可以传与类型无关的参数, 实际问题中就是需要传与类型无关的参数 就用宏, 且会在预处理期间处理好的 
// 1. 用于调用函数和从函数返回的代码可能比实际执行的这个小型计算工作所需要的时间更多, 所以宏比函数在程序
// 的规模和速度方面更胜一筹
// 2. 更为重要的是函数的参数必须声明为特定的类型, 所以函数只能在类慈宁宫合适的表达式上使用, 反之这个宏可以
// 适用于整形, 长整形, 浮点型等可以用来比较的类型, 宏是与类型无关的
// 宏相比函数也有劣势:
// 1. 每次使用宏的时候, 一份宏定义的代码将插入到程序中, 除非宏比较短, 否则可能大幅度地增减程序的长度
// 2. 宏是没发调试的(在预处理期间被处理)
// 3. 宏由于与类型无关, 也就不够严谨
// 4. 宏可能会带来运算符优先级的问题, 导致程序容易出错
// 但是宏有时候可以做函数做不到的事情,比如 宏的参数可以出现类型 但是函数做不到
#define MALLOC(num, type)\
	(type*)malloc(num * sizeof(type))// malloc函数的封装 
// 使用MALLOC(10, int); // 类型作为参数 想申请10个整形 第二个参数是类型
// 预处理器替换之后 (int*)malloc(10 * sizeof(int));
// 宏的命名 --- 把宏名全部大写, 如果是单词 建议在宏名与宏名之间加下划线, 函数名不要全部大写
// #undef (宏可以是被取消的 )
int main(){

	system("pauase");
	return 0;
}