#include <stdio.h>
#include <Windows.h>

// 条件编译(这也是为什么要写#define的原因 就是条件编译)
// 在编译一个程序的时候我们如果要将一条语句(一组语句)编译或者放弃是很方便的, 因为我们有条件编译质量,
// 本质是通过C语言特定编译结构来对代码在预处理期间相关的裁剪工作
// 通过控制这两个宏从而让我们对代码进行裁剪
#define DEBUG 1
//#define RELEASE 1
// 也可以通过命令行定义 gcc test.c -D DEBUG=1/RELEASE=1 来对代码进行动态裁剪
int main1(){
#ifdef DEBUG
	printf("debug\n");
#elif RELEASE
	printf("release\n");
#else
	printf("unknow\n");
#endif
	system("pause");
	return 0;
}

// 如何条件编译(代码裁剪)
// 常见条件编译指令
// 1. #if 常量表达式  // 用来检测常量表达式 if后面跟的是宏 宏必须为真
//			...
//    #endif
//常量表达式由预处理器求值
// 如: #define _DEBUG_ 1    // 宏定义只是单纯的被定义 则它的值是多少是随机的 但必须为真
//	   #if _DEBUG_  
//        ...
//     #endif
// 2. 多个分支的条件编译
// #if 常量表达式
//		...
// #elif 常量表达式
//		...
// #else
// 3. 判定宏是否被定义
// 什么叫做宏被定义(只要#define了 这个宏就被定义了 但成立与否 看值)
// #if defined(symbol)// 不推荐
// #ifdef symbol// 如果单纯检测宏有没有被定义 推荐这种

// #if !defined(symbol)
// #ifdef symbol
// 4. 嵌套指令    // 很少有 但是条件编译一系列的if的判定是可以进行我们嵌套的
// #if defined(OS_UNIX)
//		#ifdef OPTION1
//				unix_version_option1();
// ....

int main2(){
	int i = 0;
	int arr[10] = { 0 };
	for (i = 0; i < 10; i++){
		arr[i] = i;
#ifdef _DEBUG_  // fidef是检测是否定义了DEBUG 但明显我们这里定义了 一旦定义 再打印我们的索引值
		printf("%d\n", arr[i]);// 为了观察数组是否赋值成功
#endif// _DEBUG_
	}
	system("pause");
	return 0;
}

// 文件包含
// 一般在包含头文件时有两种方式<> 和 ""
// #include 包含一个头文件本质预处理(编译器的一个模块)先把include那些东西删掉 用头文件里的有效代码替换
// 我们已经知道, #include指令可以使另外一个文件被编译, 就像他实际出现于#include指令的地方
// 这种替换的方式很简单, 预先处理器先删除这条指令, 并用包含文件的内容替换
// 这样一个头文件被包含10次, 那就实际被编译10次 将头文件的代码拷到源文件
// 所以就必须确保一个头文件不能被重复包含, 就必须使用条件编译来对重复内容的过滤
// ""本地头文件包含(我们自己写的头文件)先在当前文件中找 没找到那编译器就像在库文件里找头文件一样 去找我们的头文件
// <>库文件包含 在于查找的区别 在标准库路径下查找头文件, 如果找不到就提示编译错误 不会在当前找
// 所以可以只使用"" 不使用<> 但是查找效率低 每次都要先在当前找 也不便于区分库文件还是本地文件

// 其他预处理指令(以上也全都是在预处理期间搞得 宏 条件编译)
